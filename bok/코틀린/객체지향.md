
### 패키지와 테스트
package 키워드를 쓰면 재사용이 가능한 라이브러리 컴포넌트를 원하는 만큼 묶을 수 있다.
패키지는 유일해야 하기 때문에 패키지 이름은 관습적으로 도메인 이름을 역순으로 한 이름으로 시작한다. 이 예제에서는 도메인 이름으로 yoururl.com을 썼다.

```kotlin
import com.yoururl.libraryname.*

fun main() {
val x = f()
}
```


- 코틀린과 자바 프로젝트를 섞어 쓰는 경우, 코틀린 스타일 가이드는 자바의 관습을 유지하는 것을 권장한다.
- 순수 코틀린 프로젝트의 경우, 프로젝트 디렉터리 구조의 최상위에 libraryname을 위치시켜라

### 객체는 모든 곳에 존재한다.
코틀린은 하이브리드 객체 - 함수형 언어다 즉, 객체 지향과 함수형 프로그램이 패러다임을 모두 지원한다.
객5체는 데이터를 저장하는  val 과 var를 포함하며, 클래스 내부에 정의된 함수를 사용해 연산을 수행한다. 클래스 내부에 정의된 함수는 멤버 함수라고 한다. 클래스는 프로퍼티와 멤버 함수를 정의하며, 새로운 사용자 정의 데이터 탕입을 정의하기 위한 프로그래밍 요소다. 클래스에 속하는  val이나 var를 만드는 것을 객체 생성이나 인스턴스 생성이라고 한다.

#### 클래스 만들기
클래스 정의는 class 키워드, 클래스 이름, 본문으로 구성되며, 본문은 없을 수도 있다. 본문에는 프로퍼티 정의나 함수 정의가 들어간다.

```Kotlin
package summary2

class NoBody

class SomeBody {
	val name = "Janet Doe"
}

class EveryBody {
	val all = listOf(SomeBody(), SomeBody());
}

fun main(){
	val nb = NoBody()
	val sb = SomeBody()
	val eb = EveryBody()
}
```

#### 생성자
생성자는 새로운 객체를 만든다. 생성자에 정보를 전달할 때는 파라미터 목록을 사용한다. 생성자 파라미터 목록은 클래스 선언의 클래스 이름 뒤에 위치한다. 생성자 호출은 이름의 첫 글자가 대문자라는 점을 제외하면 함수 호출처럼 보인다. 생성자는 클래스에 속하는 객체를 생성해 반환한다.

```Kotlin
package summary2
import atomictest.eq

classs Badger(id: String, years: Int) {
	val name = id
	val age = years
	override fun toString(): String {
		return "Badger: $name, age: $age"
	}
}

class Snake(
	var type: String,
	var length: Double
) {
	override fun toString(): String {
		return "Snake: $type, length: $length"
	}
}

class Moose(
	val age: Int,
	val height: Double
) {
	override fun toString(): String {
		return "Moose, age: $age, height: $height"
	}
}

fun main() {
	Badger("Bob", 11) eq "Badger: Bob, age: 11"
	Snake("Garden", 2.4) eq "Snake: Garden, length: 2.4"
}
```

어떨 때는 생성자 파라미터를 클래스 생성자 본문이 아닌 다른 부분에서도 참조하고 싶지만, badger의 age나 name과 같이 새로운 이름을 명시적으로 선언하고 싶지는 않을 수 있다. 이런경우 생성자 파라미터를 val이나 var로 정의하면 파라미터가 프로퍼티로 바뀌고 클래스 내부에서 이 프로퍼티에 접근할 수 있게 된다. Snake와  Moose는 이 접근 방법을 택했기 때문에 생성자 파라미터 이름을 toString() 함수 안에서 쓸 수 있다.

#### 가시성 제한하기

코틀린은 접근 변경자를 제공한다. 자바에서와 같은 언어에서 제공하는 것과 비슷하다. 접근 변경자를 사용하면 컴포넌트를 만드는 사람이 클라이언트 프로그래머에게 공개할 내용을 결정할 수 있다. 코틀린 접근 변경자에는 public, private, protected, internal이 있다.

- 변경자를 지정하지 않으면, 정의는 자동으로  public이 된다. 그러나 프로그래머는 경우에 따라 명확성을 위해 굳이 붙이지 않아도 되는 public