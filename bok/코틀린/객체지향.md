
### 패키지와 테스트
package 키워드를 쓰면 재사용이 가능한 라이브러리 컴포넌트를 원하는 만큼 묶을 수 있다.
패키지는 유일해야 하기 때문에 패키지 이름은 관습적으로 도메인 이름을 역순으로 한 이름으로 시작한다. 이 예제에서는 도메인 이름으로 yoururl.com을 썼다.

```kotlin
import com.yoururl.libraryname.*

fun main() {
val x = f()
}
```


- 코틀린과 자바 프로젝트를 섞어 쓰는 경우, 코틀린 스타일 가이드는 자바의 관습을 유지하는 것을 권장한다.
- 순수 코틀린 프로젝트의 경우, 프로젝트 디렉터리 구조의 최상위에 libraryname을 위치시켜라

### 객체는 모든 곳에 존재한다.
코틀린은 하이브리드 객체 - 함수형 언어다 즉, 객체 지향과 함수형 프로그램이 패러다임을 모두 지원한다.
객5체는 데이터를 저장하는  val 과 var를 포함하며, 클래스 내부에 정의된 함수를 사용해 연산을 수행한다. 클래스 내부에 정의된 함수는 멤버 함수라고 한다. 클래스는 프로퍼티와 멤버 함수를 정의하며, 새로운 사용자 정의 데이터 탕입을 정의하기 위한 프로그래밍 요소다. 클래스에 속하는  val이나 var를 만드는 것을 객체 생성이나 인스턴스 생성이라고 한다.

#### 클래스 만들기
클래스 정의는 class 키워드, 클래스 이름, 본문으로 구성되며, 본문은 없을 수도 있다. 본문에는 프로퍼티 정의나 함수 정의가 들어간다.

```Kotlin
package summary2

class NoBody

class SomeBody {
	val name = "Janet Doe"
}

class EveryBody {
	val all = listOf(SomeBody(), SomeBody());
}

fun main(){
	val nb = NoBody()
	val sb = SomeBody()
	val eb = EveryBody()
}
```

#### 생성자
생성자는 새로운 객체를 만든다. 생성자에 정보를 전달할 때는 파라미터 목록을 사용한다. 생성자 파라미터 목록은 클래스 선언의 클래스 이름 뒤에 위치한다. 생성자 호출은 이름의 첫 글자가 대문자라는 점을 제외하면 함수 호출처럼 보인다. 생성자는 클래스에 속하는 객체를 생성해 반환한다.

```Kotlin
package summary2
import atomictest.eq

classs Badger(id: String, years: Int) {
	val name = id
	val age = years
	override fun toString(): String {
		return "Badger: $name, age: $age"
	}
}

class Snake(
	var type: String,
	var length: Double
) {
	override fun toString(): String {
		return "Snake: $type, length: $length"
	}
}

class Moose(
	val age: Int,
	val height: Double
) {

}
```